/**
 * Export/Import utilities for various i18n file formats
 * Supports: JSON, XLIFF 1.2/2.0, PO/gettext, CSV, Android XML, iOS strings
 */

import * as fs from 'fs';
import * as path from 'path';

export interface TranslationUnit {
    key: string;
    source: string;
    target: string;
    notes?: string;
    context?: string;
    state?: 'new' | 'translated' | 'reviewed' | 'final';
}

export interface TranslationDocument {
    sourceLanguage: string;
    targetLanguage: string;
    units: TranslationUnit[];
    metadata?: Record<string, string>;
}

/**
 * XLIFF 1.2 Export/Import
 */
export const XLIFFFormat = {
    export(doc: TranslationDocument): string {
        const units = doc.units.map(unit => `
    <trans-unit id="${escapeXml(unit.key)}" xml:space="preserve">
      <source>${escapeXml(unit.source)}</source>
      <target${unit.state ? ` state="${unit.state}"` : ''}>${escapeXml(unit.target)}</target>
      ${unit.notes ? `<note>${escapeXml(unit.notes)}</note>` : ''}
      ${unit.context ? `<context-group><context context-type="description">${escapeXml(unit.context)}</context></context-group>` : ''}
    </trans-unit>`).join('\n');

        return `<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <file source-language="${doc.sourceLanguage}" target-language="${doc.targetLanguage}" datatype="plaintext" original="translations">
    <header>
      <tool tool-id="multilingual-cli" tool-name="multilingual-cli" tool-version="2.0.0"/>
    </header>
    <body>${units}
    </body>
  </file>
</xliff>`;
    },

    import(content: string): TranslationDocument {
        const units: TranslationUnit[] = [];

        // Extract source and target languages
        const sourceMatch = content.match(/source-language="([^"]+)"/);
        const targetMatch = content.match(/target-language="([^"]+)"/);

        // Extract trans-units
        const unitRegex = /<trans-unit[^>]*id="([^"]*)"[^>]*>[\s\S]*?<source>([\s\S]*?)<\/source>[\s\S]*?<target[^>]*>([\s\S]*?)<\/target>[\s\S]*?<\/trans-unit>/g;

        let match;
        while ((match = unitRegex.exec(content)) !== null) {
            units.push({
                key: unescapeXml(match[1]),
                source: unescapeXml(match[2]),
                target: unescapeXml(match[3]),
            });
        }

        return {
            sourceLanguage: sourceMatch?.[1] || 'en',
            targetLanguage: targetMatch?.[1] || 'en',
            units,
        };
    },
};

/**
 * XLIFF 2.0 Export/Import
 */
export const XLIFF2Format = {
    export(doc: TranslationDocument): string {
        const units = doc.units.map((unit, idx) => `
    <unit id="${idx + 1}">
      <notes>
        <note category="key">${escapeXml(unit.key)}</note>
        ${unit.notes ? `<note category="description">${escapeXml(unit.notes)}</note>` : ''}
      </notes>
      <segment${unit.state ? ` state="${unit.state}"` : ''}>
        <source>${escapeXml(unit.source)}</source>
        <target>${escapeXml(unit.target)}</target>
      </segment>
    </unit>`).join('\n');

        return `<?xml version="1.0" encoding="UTF-8"?>
<xliff version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" srcLang="${doc.sourceLanguage}" trgLang="${doc.targetLanguage}">
  <file id="translations">
    ${units}
  </file>
</xliff>`;
    },

    import(content: string): TranslationDocument {
        const units: TranslationUnit[] = [];

        const srcLangMatch = content.match(/srcLang="([^"]+)"/);
        const trgLangMatch = content.match(/trgLang="([^"]+)"/);

        const unitRegex = /<unit[^>]*>[\s\S]*?<note category="key">([\s\S]*?)<\/note>[\s\S]*?<source>([\s\S]*?)<\/source>[\s\S]*?<target>([\s\S]*?)<\/target>[\s\S]*?<\/unit>/g;

        let match;
        while ((match = unitRegex.exec(content)) !== null) {
            units.push({
                key: unescapeXml(match[1]),
                source: unescapeXml(match[2]),
                target: unescapeXml(match[3]),
            });
        }

        return {
            sourceLanguage: srcLangMatch?.[1] || 'en',
            targetLanguage: trgLangMatch?.[1] || 'en',
            units,
        };
    },
};

/**
 * PO/gettext Export/Import
 */
export const POFormat = {
    export(doc: TranslationDocument): string {
        const header = `# Translation file for ${doc.targetLanguage}
# Generated by multilingual-cli
# https://github.com/NagusameCS/Multilingual
#
msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\\n"
"Content-Transfer-Encoding: 8bit\\n"
"Language: ${doc.targetLanguage}\\n"
"Generated-By: multilingual-cli 2.0.0\\n"
`;

        const entries = doc.units.map(unit => {
            const lines: string[] = [];

            if (unit.notes || unit.context) {
                lines.push(`#. ${unit.notes || unit.context}`);
            }

            // Add key as reference
            lines.push(`#: ${unit.key}`);

            // Handle multiline strings
            if (unit.source.includes('\n')) {
                lines.push('msgid ""');
                unit.source.split('\n').forEach(line => {
                    lines.push(`"${escapePO(line)}\\n"`);
                });
            } else {
                lines.push(`msgid "${escapePO(unit.source)}"`);
            }

            if (unit.target.includes('\n')) {
                lines.push('msgstr ""');
                unit.target.split('\n').forEach(line => {
                    lines.push(`"${escapePO(line)}\\n"`);
                });
            } else {
                lines.push(`msgstr "${escapePO(unit.target)}"`);
            }

            return lines.join('\n');
        }).join('\n\n');

        return header + '\n' + entries;
    },

    import(content: string): TranslationDocument {
        const units: TranslationUnit[] = [];

        // Extract language from header
        const langMatch = content.match(/"Language:\s*([^\\]+)\\n"/);

        // Split into entries
        const entries = content.split(/\n\n+/).filter(entry => entry.includes('msgid') && !entry.startsWith('msgid ""'));

        for (const entry of entries) {
            const keyMatch = entry.match(/#:\s*(.+)/);
            const msgidMatch = entry.match(/msgid\s+"(.+)"/);
            const msgstrMatch = entry.match(/msgstr\s+"(.+)"/);

            if (msgidMatch && msgstrMatch) {
                units.push({
                    key: keyMatch?.[1] || msgidMatch[1],
                    source: unescapePO(msgidMatch[1]),
                    target: unescapePO(msgstrMatch[1]),
                });
            }
        }

        return {
            sourceLanguage: 'en',
            targetLanguage: langMatch?.[1] || 'en',
            units,
        };
    },
};

/**
 * CSV Export/Import
 */
export const CSVFormat = {
    export(doc: TranslationDocument, includeNotes = true): string {
        const headers = includeNotes
            ? ['key', 'source', 'target', 'notes', 'state']
            : ['key', 'source', 'target'];

        const rows = [headers.join(',')];

        for (const unit of doc.units) {
            const row = includeNotes
                ? [
                    escapeCSV(unit.key),
                    escapeCSV(unit.source),
                    escapeCSV(unit.target),
                    escapeCSV(unit.notes || ''),
                    escapeCSV(unit.state || 'new'),
                ]
                : [
                    escapeCSV(unit.key),
                    escapeCSV(unit.source),
                    escapeCSV(unit.target),
                ];
            rows.push(row.join(','));
        }

        return rows.join('\n');
    },

    import(content: string): TranslationDocument {
        const lines = content.split('\n').filter(line => line.trim());
        const units: TranslationUnit[] = [];

        // Skip header row
        for (let i = 1; i < lines.length; i++) {
            const values = parseCSVLine(lines[i]);
            if (values.length >= 3) {
                units.push({
                    key: values[0],
                    source: values[1],
                    target: values[2],
                    notes: values[3] || undefined,
                    state: (values[4] as TranslationUnit['state']) || undefined,
                });
            }
        }

        return {
            sourceLanguage: 'en',
            targetLanguage: 'unknown',
            units,
        };
    },
};

/**
 * Android strings.xml Export/Import
 */
export const AndroidXMLFormat = {
    export(doc: TranslationDocument): string {
        const entries = doc.units.map(unit => {
            const escapedValue = escapeXml(unit.target)
                .replace(/'/g, "\\'")
                .replace(/\n/g, '\\n');

            const comment = unit.notes ? `    <!-- ${escapeXml(unit.notes)} -->\n` : '';
            return `${comment}    <string name="${escapeXml(unit.key)}">${escapedValue}</string>`;
        }).join('\n');

        return `<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by multilingual-cli -->
<!-- https://github.com/NagusameCS/Multilingual -->
<resources>
${entries}
</resources>`;
    },

    import(content: string): TranslationDocument {
        const units: TranslationUnit[] = [];

        const stringRegex = /<string\s+name="([^"]+)"[^>]*>([\s\S]*?)<\/string>/g;

        let match;
        while ((match = stringRegex.exec(content)) !== null) {
            units.push({
                key: unescapeXml(match[1]),
                source: unescapeXml(match[2]),
                target: unescapeXml(match[2]),
            });
        }

        return {
            sourceLanguage: 'en',
            targetLanguage: 'unknown',
            units,
        };
    },
};

/**
 * iOS Localizable.strings Export/Import
 */
export const IOSStringsFormat = {
    export(doc: TranslationDocument): string {
        const header = `/* 
  Localizable.strings
  Generated by multilingual-cli
  https://github.com/NagusameCS/Multilingual
*/

`;

        const entries = doc.units.map(unit => {
            const comment = unit.notes ? `/* ${unit.notes} */\n` : '';
            const key = escapeIOSString(unit.key);
            const value = escapeIOSString(unit.target);
            return `${comment}"${key}" = "${value}";`;
        }).join('\n\n');

        return header + entries;
    },

    import(content: string): TranslationDocument {
        const units: TranslationUnit[] = [];

        const stringRegex = /"([^"\\]*(?:\\.[^"\\]*)*)"\s*=\s*"([^"\\]*(?:\\.[^"\\]*)*)"/g;

        let match;
        while ((match = stringRegex.exec(content)) !== null) {
            units.push({
                key: unescapeIOSString(match[1]),
                source: unescapeIOSString(match[2]),
                target: unescapeIOSString(match[2]),
            });
        }

        return {
            sourceLanguage: 'en',
            targetLanguage: 'unknown',
            units,
        };
    },
};

/**
 * ARB (Flutter) Export/Import
 */
export const ARBFormat = {
    export(doc: TranslationDocument): string {
        const arb: Record<string, unknown> = {
            '@@locale': doc.targetLanguage,
            '@@last_modified': new Date().toISOString(),
        };

        for (const unit of doc.units) {
            arb[unit.key] = unit.target;

            if (unit.notes || unit.context) {
                arb[`@${unit.key}`] = {
                    description: unit.notes || unit.context,
                };
            }
        }

        return JSON.stringify(arb, null, 2);
    },

    import(content: string): TranslationDocument {
        const arb = JSON.parse(content);
        const units: TranslationUnit[] = [];

        for (const [key, value] of Object.entries(arb)) {
            if (!key.startsWith('@') && typeof value === 'string') {
                const meta = arb[`@${key}`] as { description?: string } | undefined;
                units.push({
                    key,
                    source: value,
                    target: value,
                    notes: meta?.description,
                });
            }
        }

        return {
            sourceLanguage: 'en',
            targetLanguage: (arb['@@locale'] as string) || 'unknown',
            units,
        };
    },
};

// =========================================================================
// Helper functions
// =========================================================================

function escapeXml(str: string): string {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}

function unescapeXml(str: string): string {
    return str
        .replace(/&apos;/g, "'")
        .replace(/&quot;/g, '"')
        .replace(/&gt;/g, '>')
        .replace(/&lt;/g, '<')
        .replace(/&amp;/g, '&');
}

function escapePO(str: string): string {
    return str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\t/g, '\\t');
}

function unescapePO(str: string): string {
    return str
        .replace(/\\t/g, '\t')
        .replace(/\\"/g, '"')
        .replace(/\\n/g, '\n')
        .replace(/\\\\/g, '\\');
}

function escapeCSV(str: string): string {
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
}

function parseCSVLine(line: string): string[] {
    const result: string[] = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
        const char = line[i];

        if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
                current += '"';
                i++;
            } else {
                inQuotes = !inQuotes;
            }
        } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
        } else {
            current += char;
        }
    }

    result.push(current);
    return result;
}

function escapeIOSString(str: string): string {
    return str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\t/g, '\\t');
}

function unescapeIOSString(str: string): string {
    return str
        .replace(/\\t/g, '\t')
        .replace(/\\n/g, '\n')
        .replace(/\\"/g, '"')
        .replace(/\\\\/g, '\\');
}

// =========================================================================
// File operations
// =========================================================================

export function exportToFile(
    doc: TranslationDocument,
    filePath: string,
    format?: 'json' | 'xliff' | 'xliff2' | 'po' | 'csv' | 'android' | 'ios' | 'arb'
): void {
    const ext = format || getFormatFromPath(filePath);
    let content: string;

    switch (ext) {
        case 'xliff':
            content = XLIFFFormat.export(doc);
            break;
        case 'xliff2':
            content = XLIFF2Format.export(doc);
            break;
        case 'po':
            content = POFormat.export(doc);
            break;
        case 'csv':
            content = CSVFormat.export(doc);
            break;
        case 'android':
            content = AndroidXMLFormat.export(doc);
            break;
        case 'ios':
            content = IOSStringsFormat.export(doc);
            break;
        case 'arb':
            content = ARBFormat.export(doc);
            break;
        case 'json':
        default:
            const json: Record<string, string> = {};
            for (const unit of doc.units) {
                json[unit.key] = unit.target;
            }
            content = JSON.stringify(json, null, 2);
            break;
    }

    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(filePath, content, 'utf-8');
}

export function importFromFile(filePath: string): TranslationDocument {
    const content = fs.readFileSync(filePath, 'utf-8');
    const format = getFormatFromPath(filePath);

    switch (format) {
        case 'xliff':
        case 'xliff2':
            if (content.includes('version="2.0"')) {
                return XLIFF2Format.import(content);
            }
            return XLIFFFormat.import(content);
        case 'po':
            return POFormat.import(content);
        case 'csv':
            return CSVFormat.import(content);
        case 'android':
            return AndroidXMLFormat.import(content);
        case 'ios':
            return IOSStringsFormat.import(content);
        case 'arb':
            return ARBFormat.import(content);
        case 'json':
        default:
            const json = JSON.parse(content);
            const units: TranslationUnit[] = [];

            for (const [key, value] of Object.entries(json)) {
                if (typeof value === 'string') {
                    units.push({
                        key,
                        source: value,
                        target: value,
                    });
                }
            }

            return {
                sourceLanguage: 'en',
                targetLanguage: 'unknown',
                units,
            };
    }
}

function getFormatFromPath(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const base = path.basename(filePath).toLowerCase();

    if (ext === '.xliff' || ext === '.xlf') return 'xliff';
    if (ext === '.po') return 'po';
    if (ext === '.pot') return 'po';
    if (ext === '.csv') return 'csv';
    if (ext === '.arb') return 'arb';
    if (base === 'strings.xml') return 'android';
    if (ext === '.strings') return 'ios';

    return 'json';
}

/**
 * Convert between formats
 */
export function convertFormat(
    inputPath: string,
    outputPath: string,
    targetLanguage?: string
): void {
    const doc = importFromFile(inputPath);

    if (targetLanguage) {
        doc.targetLanguage = targetLanguage;
    }

    exportToFile(doc, outputPath);
}

/**
 * Merge translation files
 */
export function mergeTranslations(
    basePath: string,
    updatePath: string,
    outputPath?: string
): TranslationDocument {
    const base = importFromFile(basePath);
    const update = importFromFile(updatePath);

    const updateMap = new Map(update.units.map(u => [u.key, u]));

    for (const unit of base.units) {
        const updatedUnit = updateMap.get(unit.key);
        if (updatedUnit) {
            unit.target = updatedUnit.target;
            unit.state = 'translated';
            updateMap.delete(unit.key);
        }
    }

    // Add new translations
    for (const [, unit] of updateMap) {
        base.units.push(unit);
    }

    if (outputPath) {
        exportToFile(base, outputPath);
    }

    return base;
}
